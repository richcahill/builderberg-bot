require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const OpenAI = require('openai');
const Redis = require('redis');

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Initialize Redis with retry strategy
const redisClient = Redis.createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379',
  retry_strategy: function(options) {
    if (options.total_retry_time > 1000 * 60 * 60) {
      // Stop retrying after 1 hour
      return new Error('Retry time exhausted');
    }
    if (options.attempt > 10) {
      // Stop retrying after 10 attempts
      return undefined;
    }
    // Retry with exponential backoff
    return Math.min(options.attempt * 100, 3000);
  }
});

let redisConnected = false;
redisClient.on('error', err => {
  console.log('Redis Client Error:', err.message);
  redisConnected = false;
});

redisClient.on('connect', () => {
  console.log('Successfully connected to Redis');
  redisConnected = true;
});

// Initialize Express
const app = express();
const port = 5000;

// Initialize Telegram Bot
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });

// Store messages in memory (we'll add database integration later)
const messageStore = new Map();

// Helper function to generate summary
async function generateSummary(messages) {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { 
          role: "system", 
          content: "You are a helpful assistant that summarizes conversations." 
        },
        {
          role: "user",
          content: `Please summarize the following conversation in brief, clear bullet points. Focus on the main topics and key points discussed:\n\n${messages.join('\n')}`
        }
      ],
      max_tokens: 300,
      temperature: 0.7
    });

    return completion.choices[0].message.content.trim();
  } catch (error) {
    console.error('Error generating summary:', error);
    throw error;
  }
}

// Format summary for Telegram
function formatSummary(summary) {
  const header = 'üìù <b>Conversation Summary</b>\n\n';
  const formattedBody = summary
    .split('\n')
    .map(line => line.trim())
    .filter(line => line)
    .map(line => {
      if (line.startsWith('‚Ä¢') || line.startsWith('-')) {
        return '‚Ä¢ ' + line.slice(1).trim();
      }
      return '‚Ä¢ ' + line;
    })
    .join('\n');
  
  const footer = '\n\n<i>Generated by AI Summary Bot</i>';
  
  return header + formattedBody + footer;
}

// Bot command handlers
bot.onText(/\/ai_summarise/, async (msg) => {
  const chatId = msg.chat.id;
  try {
    // Check cache first if Redis is connected
    if (redisConnected) {
      try {
        const cacheKey = `summary_${chatId}`;
        const cachedSummary = await redisClient.get(cacheKey);
        
        if (cachedSummary) {
          await bot.sendMessage(chatId, cachedSummary, { parse_mode: 'HTML' });
          return;
        }
      } catch (error) {
        console.log('Redis cache check failed:', error.message);
        // Continue without cache if Redis fails
      }
    }

    const messages = messageStore.get(chatId) || [];
    if (messages.length === 0) {
      await bot.sendMessage(chatId, "No messages to summarize yet!");
      return;
    }

    const summary = await generateSummary(messages);
    const formattedSummary = formatSummary(summary);
    
    // Cache the formatted summary if Redis is connected
    if (redisConnected) {
      try {
        await redisClient.set(cacheKey, formattedSummary, { EX: 3600 }); // 1 hour expiry
        console.log('Summary cached successfully');
      } catch (error) {
        console.log('Failed to cache summary:', error.message);
        // Continue without caching if Redis fails
      }
    }
    
    await bot.sendMessage(chatId, formattedSummary, { parse_mode: 'HTML' });
  } catch (error) {
    console.error('Error in summarize command:', error);
    await bot.sendMessage(chatId, "Sorry, I couldn't generate a summary at this time.");
  }
});

// Store messages
bot.on('message', (msg) => {
  if (msg.text && !msg.text.startsWith('/')) {
    const chatId = msg.chat.id;
    const messages = messageStore.get(chatId) || [];
    messages.push(msg.text);
    
    // Keep only last 20 messages
    if (messages.length > 20) {
      messages.shift();
    }
    
    messageStore.set(chatId, messages);
  }
});

// Express routes
app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

// Start the server and connect to Redis
async function startServer() {
  try {
    // Start Express server first
    app.listen(port, '0.0.0.0', () => {
      console.log(`Server is running on port ${port}`);
    });

    // Try to connect to Redis, but don't fail if it's not available
    try {
      await redisClient.connect();
      console.log('Connected to Redis');
    } catch (error) {
      console.log('Redis connection failed, continuing without caching:', error.message);
      // Continue without Redis
    }
  } catch (error) {
    console.error('Error starting server:', error);
    process.exit(1);
  }
}

// Start everything
startServer().catch((error) => {
  console.error('Fatal error starting server:', error);
  process.exit(1);
});

// Error handling
process.on('unhandledRejection', (error) => {
  console.error('Unhandled rejection:', error);
});

process.on('SIGTERM', async () => {
  await redisClient.quit();
  process.exit(0);
});
