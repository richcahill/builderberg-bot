require('dotenv').config();
const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const OpenAI = require('openai');
const { sequelize, TelegramGroup, Message } = require('./database');

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Test database connection
async function initDatabase() {
  try {
    await sequelize.authenticate();
    console.log('Successfully connected to PostgreSQL database');
  } catch (error) {
    console.error('Unable to connect to the database:', error);
  }
}

// Initialize database connection
initDatabase();

// Initialize Express
const app = express();
const port = 5000;

// Initialize Telegram Bot
console.log('Initializing Telegram bot...');
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });

// Add bot error handler
bot.on('error', (error) => {
  console.error('Telegram bot error:', error.message);
});

// Add polling error handler
bot.on('polling_error', (error) => {
  console.error('Polling error:', error.message);
});

// Log successful bot initialization
bot.getMe().then((botInfo) => {
  console.log('Bot initialized successfully!');
  console.log(`Bot username: @${botInfo.username}`);
}).catch((error) => {
  console.error('Error getting bot info:', error.message);
});

// Store messages in memory (we'll add database integration later)
const messageStore = new Map();

// Helper function to generate summary
async function generateSummary(messages) {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { 
          role: "system", 
          content: "You are a helpful assistant that summarizes conversations." 
        },
        {
          role: "user",
          content: `Please summarize the following conversation in brief, clear bullet points. Focus on the main topics and key points discussed:\n\n${messages.join('\n')}`
        }
      ],
      max_tokens: 300,
      temperature: 0.7
    });

    return completion.choices[0].message.content.trim();
  } catch (error) {
    console.error('Error generating summary:', error);
    throw error;
  }
}

// Format summary for Telegram
function formatSummary(summary) {
  const header = 'üìù <b>Conversation Summary</b>\n\n';
  const formattedBody = summary
    .split('\n')
    .map(line => line.trim())
    .filter(line => line)
    .map(line => {
      if (line.startsWith('‚Ä¢') || line.startsWith('-')) {
        return '‚Ä¢ ' + line.slice(1).trim();
      }
      return '‚Ä¢ ' + line;
    })
    .join('\n');
  
  const footer = '\n\n<i>Generated by AI Summary Bot</i>';
  
  return header + formattedBody + footer;
}

// Bot command handlers
bot.onText(/\/ai_summarise/, async (msg) => {
  const chatId = msg.chat.id;
  try {
    console.log(`Received summarize request from chat ${chatId}`);
    let cacheKey = `summary_${chatId}`;

    // Try cache first if Redis is available
    if (redisConnected) {
      try {
        const cachedSummary = await redisClient.get(cacheKey);
        if (cachedSummary) {
          console.log('Using cached summary');
          await bot.sendMessage(chatId, cachedSummary, { parse_mode: 'HTML' });
          return;
        }
      } catch (error) {
        console.log('Redis cache check failed, continuing without cache:', error.message);
      }
    }

    // Get messages from memory store
    const messages = messageStore.get(chatId) || [];
    if (messages.length === 0) {
      console.log('No messages found for summarization');
      await bot.sendMessage(chatId, "No messages to summarize yet! Send some messages first.");
      return;
    }

    // Generate and format summary
    console.log(`Generating summary for ${messages.length} messages`);
    const summary = await generateSummary(messages);
    const formattedSummary = formatSummary(summary);
    
    // Try to cache the result if Redis is available
    if (redisConnected) {
      try {
        await redisClient.set(cacheKey, formattedSummary, { EX: 3600 }); // 1 hour expiry
        console.log('Summary cached successfully');
      } catch (error) {
        console.log('Failed to cache summary, continuing without caching:', error.message);
      }
    }
    
    // Send the response
    console.log('Sending formatted summary to chat');
    await bot.sendMessage(chatId, formattedSummary, { parse_mode: 'HTML' });
  } catch (error) {
    console.error('Error in summarize command:', error);
    await bot.sendMessage(chatId, "Sorry, I couldn't generate a summary at this time. Please try again later.");
  }
});

// Store messages
bot.on('message', (msg) => {
  if (msg.text && !msg.text.startsWith('/')) {
    const chatId = msg.chat.id;
    const messages = messageStore.get(chatId) || [];
    messages.push(msg.text);
    
    // Keep only last 20 messages
    if (messages.length > 20) {
      messages.shift();
    }
    
    messageStore.set(chatId, messages);
  }
});

// Express routes
app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

// Start the server and connect to Redis
async function startServer() {
  try {
    // Start Express server first
    app.listen(port, '0.0.0.0', () => {
      console.log(`Server is running on port ${port}`);
    });

    // Try to connect to Redis, but don't fail if it's not available
    try {
      await redisClient.connect();
      console.log('Connected to Redis');
    } catch (error) {
      console.log('Redis connection failed, continuing without caching:', error.message);
      // Continue without Redis
    }
  } catch (error) {
    console.error('Error starting server:', error);
    process.exit(1);
  }
}

// Start everything
startServer().catch((error) => {
  console.error('Fatal error starting server:', error);
  process.exit(1);
});

// Error handling
process.on('unhandledRejection', (error) => {
  console.error('Unhandled rejection:', error);
});

// Graceful shutdown handler
async function shutdown(signal) {
  console.log(`\nReceived ${signal}. Starting graceful shutdown...`);
  try {
    if (redisConnected) {
      console.log('Closing Redis connection...');
      await redisClient.quit();
    }
    console.log('Stopping Telegram bot...');
    bot.close();
    console.log('Cleanup complete. Exiting...');
  } catch (error) {
    console.error('Error during shutdown:', error);
  }
  process.exit(0);
}

// Handle termination signals
process.on('SIGTERM', () => shutdown('SIGTERM'));
process.on('SIGINT', () => shutdown('SIGINT'));
